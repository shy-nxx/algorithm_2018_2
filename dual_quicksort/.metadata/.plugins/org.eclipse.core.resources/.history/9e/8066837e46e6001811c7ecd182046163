import java.util.Random;
import java.util.Scanner;

public class DualpivotSort {

	public static void main(String[] args) {

		Random random = new Random();
		int[] array = new int[10000];
		for (int i = 0; i < array.length; i++) {
			array[i] = random.nextInt(10000);
		}

		long start_time = System.currentTimeMillis();
		
		// Sort the Array using Quick Sort
		quickSortDualPivot(array,0, array.length-1);
		long end_time = System.currentTimeMillis();

		System.out.println("time for computation = " + (end_time - start_time) + "ms");
//		// Print the final answer to the User:
		System.out.println("Sorted Array: ");

		for (int x : array){
			System.out.print(x + " ");
		}

		System.out.println();
	}

	private static void swap(int[] a, int i, int j) {
		int temp = a[i];
		a[i] = a[j];
		a[j] = temp; 
	}
	
	public static void quickSortDualPivot(int[] array, int low, int high){
		// Check if low is greater than high
		// This is the break condition for the Recursive Solution
		if (low >= high) {
			return;
		}

		int lt = low + 1;
		int ht = high - 1;

		if ((ht - lt) < 17) { // insertion sort for tiny array
			for (int i = lt + 1; i <= ht; i++) {
				for (int j = i; j > lt && array[j] < array[j - 1]; j--) {
					swap(array, j, j - 1);
				}
			}
			return; 
		}
		
		
		// Swap 'low' and 'high' if neccessary
		if (array[low] > array[high]) {
			int temp = array[low];
			array[low] = array[high];
			array[high] = temp;
			
		}

		// If only two elements are there
		// the previous step made sure that they're already sorted
		if (low + 1 == high) {
			return;
		}

		for (int i = low + 1;i <= high; i++) {
			if (i > ht) {
				// Every value above this index
				// will have a value > array[high]
				break;
			}

			if (array[i] < array[low]) {
				// array[i] < pivot1, so,
				// it is placed in first sub-array
				int temp = array[lt];
				array[lt] = array[i];
				array[i] = temp;
				lt++;
			} else if (array[i] > array[high]) {
				// array[i] > pivot2, so,
				// it is placed in the third sub-array
				int temp = array[ht];
				array[ht] = array[i];
				array[i] = temp;
				ht--;
				i--;
			}

			// The value of array[i] that does not go to either
			// of the cases, falls in the second sub-array
		}

		// Swapping the two-pivots to correct places
		ht++;
		int temp = array[ht];
		array[ht] = array[high];
		array[high] = temp;
		lt--;
		temp = array[lt];
		array[lt] = array[low];
		array[low] = temp;

		// Recursively do the same to the sub-arrays
		quickSortDualPivot(array, low, lt - 1);
		quickSortDualPivot(array, lt + 1, ht - 1);
		quickSortDualPivot(array, ht + 1, high);
	}

}
